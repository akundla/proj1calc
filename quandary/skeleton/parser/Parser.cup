package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

terminal PLUS, MINUS, MULT, UMINUS;
terminal LPAREN, RPAREN;
terminal RET, SEMI;
terminal INT;
terminal IF, ELSE;
terminal LESS_THAN, LESS_THAN_OR_EQUAL_TO, GREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUALITY_CHECK, NON_EQUALITY_CHECK;
terminal BOOL_AND, BOOL_OR;
terminal ASSIGNMENT;
terminal BOOL_NOT;

terminal Long    INTCONST;

non terminal Program         program;
non terminal Expr            expr;
non terminal BinaryExpr      binaryExpr;

precedence left PLUS, MINUS;
// MULT goes one line below because it is higher precedence than either PLUS or MINUS
precedence left MULT;
// UMINUS is highest precedence
precedence left UMINUS;

start with program;

program ::= RET expr:e SEMI
            {: RESULT = new Program(e, loc(eleft, eright)); :}
         ;

expr ::= INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      |  binaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
      |  MINUS expr:e
         {: RESULT = new UnaryExpr(UnaryExpr.UNARY_NEGATION, e, loc(eleft, eright)); :}
         %prec UMINUS
      ;
// %prec is there to give the whole production the precedence of UMINUS instead of merely expr
// Doing 0 minus EXPR is simpler than modifying the ast nodes 

binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MULT expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MULT, e2, loc(e1left, e1right)); :}
            ;
